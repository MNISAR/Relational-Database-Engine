package btree;

import static tests.TestDriver.FAIL;
import static tests.TestDriver.OK;

import java.io.IOException;
import java.util.Arrays;
import java.util.List;

import bufmgr.PageNotReadException;
import global.AttrType;
import global.ExtendedSystemDefs;
import global.GlobalConst;
import global.RID;
import global.SystemDefs;
import btree.*;
import heap.FieldNumberOutOfBoundException;
import heap.FileAlreadyDeletedException;
import heap.HFBufMgrException;
import heap.HFDiskMgrException;
import heap.HFException;
import heap.Heapfile;
import heap.InvalidSlotNumberException;
import heap.InvalidTupleSizeException;
import heap.InvalidTypeException;
import heap.Scan;
import heap.Tuple;
import index.IndexException;
import iterator.FileScan;
import iterator.TupleUtils;
import iterator.Iterator;
import iterator.JoinsException;
import iterator.LowMemException;
import iterator.PredEvalException;
import iterator.SortException;
import iterator.SortPref;
import iterator.TupleUtils;
import iterator.TupleUtilsException;
import iterator.UnknowAttrType;
import iterator.UnknownKeyTypeException;
import iterator.BlockNestedLoopsSky;


/**
 * BTreeSortedSky(
 * AttrType[] in1, 
 * int len_in1, 
 * short[] t1_str_sizes, 
 * int Iterator am1, 
 java.lang.String relationName,
 int[] pref_list,
 int[] pref_list_length,
 IndexFile index_file,
 int n_pages)
 * @author kunjpatel
 *
 */

public class BTreeSortedSky extends Iterator implements GlobalConst {

	private AttrType[] attrType;
	private int attr_len;
	private short[] t1_str_sizes;
	String relationName;
	private int[] pref_list;
	private int pref_list_length;
	private IndexFile index_file;
	private int n_pages;

	private int window_size;
	boolean status = OK;
	private static Tuple[] _window;
	private int counter;

	private Heapfile temp;
	private Heapfile tuples;
	private int temp_rcrd_count;

	private BlockNestedLoopsSky bnls;

	public BTreeSortedSky(AttrType[] attrType, int attr_len, short[] t1_str_sizes, int amt_of_mem, Iterator am1,
						  String relationName, int[] pref_list, int pref_list_length, IndexFile index_file,
						  int n_pages) throws Exception {

		this.counter = 0;
		this.relationName = relationName;
		this.index_file = (BTreeFile) index_file;
		this.attrType = attrType;
		this.attr_len = attr_len;
		this.t1_str_sizes = t1_str_sizes;
		this.pref_list = pref_list;
		this.pref_list_length = pref_list_length;
		this.n_pages = n_pages;

		try {
			// temp heap file to store overflown skyline objects
			temp = new Heapfile("btreeSortSkyTemp.in");
		}
		catch (Exception e) {
			status = FAIL;
			e.printStackTrace();
		}

		tuples = new Heapfile(this.relationName);

	}



	public void computeSkylines() throws  Exception {
		System.out.println("Compute skyline ");

		BTFileScan scan = ((BTreeFile) index_file).new_scan(null, null);
		KeyDataEntry entry;
		RID rid;

		Tuple t = getEmptyTuple();
		System.out.println("Number of pages "+n_pages);
		this.window_size = ((int)(MINIBASE_PAGESIZE/t.size()))*(n_pages);
		System.out.println("Tuple size "+t.size());
		System.out.println("SIZE: " + window_size);

		_window = new Tuple[window_size];
		System.out.println("Windows size in btree sorted sky: "+ _window.length);
		entry = scan.get_next();

		int count = 0;

		while (entry != null && count < _window.length) {
			Tuple temp = getEmptyTuple();
			rid = ((LeafData) entry.data).getData();
			temp.tupleCopy(tuples.getRecord(rid));
			//temp.print(attrType);

			boolean isDominatedByWindow = checkDominationWithinWindowTuples(temp,count);

			if(!isDominatedByWindow) {
				_window[count++] = temp;
			}

			entry = scan.get_next();
		}
		while (entry != null) {
			boolean isDominatedBy = false;
			Tuple htuple = getEmptyTuple();

			rid = ((LeafData) entry.data).getData();
			htuple.tupleCopy(tuples.getRecord(rid));

			for(int i=0; i<_window.length; i++){
				if (_window[i] != null) {
					if (TupleUtils.Dominates(_window[i], attrType, htuple, attrType, (short) attr_len, t1_str_sizes, pref_list, pref_list_length)) {
						isDominatedBy = true;
						break;
					}
				}
			}

			if(!isDominatedBy){
				if(count < _window.length){
					_window[count++] = htuple;
				}else {
					try {
						rid = temp.insertRecord(htuple.returnTupleByteArray());

					} catch (Exception e) {
						status = FAIL;
						e.printStackTrace();
					}
				}
			}

			try {
				entry = scan.get_next();
			}
			catch (Exception e) {
				status = FAIL;
				e.printStackTrace();
			}
		}

		((BTreeFile) index_file).close();
		scan.DestroyBTreeFileScan();

		SystemDefs.JavabaseBM.flushAllPages();
		System.out.println("record count in temporary file: "+temp.getRecCnt());
		this.temp_rcrd_count = temp.getRecCnt();
		if( temp_rcrd_count == 0)
			return;

		bnls = new BlockNestedLoopsSky(
				attrType,
				attr_len,
				t1_str_sizes,
				null,
				"btreeSortSkyTemp.in",
				pref_list,
				pref_list_length,
				n_pages
		);
		return;
	}

	private boolean checkDominationWithinWindowTuples(Tuple temp, int count) throws TupleUtilsException, UnknowAttrType, FieldNumberOutOfBoundException, IOException {
		if(count == 0) return false;

		for(int i = 0; i < count; i++) {
			if (TupleUtils.Dominates(_window[i] , attrType, temp, attrType, (short) attr_len, t1_str_sizes, pref_list, pref_list_length)) {
				return true;
			}
		}

		return false;
	}


	private Tuple getEmptyTuple() throws InvalidTypeException, InvalidTupleSizeException, IOException {
		Tuple t = new Tuple();
		t.setHdr((short) attrType.length, attrType, t1_str_sizes);
		int size = t.size();
		t = new Tuple(size);
		t.setHdr((short) attrType.length, attrType, t1_str_sizes);
		return t;
	}



	@Override
	public Tuple get_next() throws IOException, JoinsException, IndexException, InvalidTupleSizeException,
			InvalidTypeException, PageNotReadException, TupleUtilsException, PredEvalException, SortException,
			LowMemException, UnknowAttrType, UnknownKeyTypeException, Exception {
		// TODO Auto-generated method stub
		if ( this.counter < this.window_size ) {
			Tuple skl = _window[counter];
			counter++;

			if ( skl != null ) {
				return skl;
			}
		}
		if ( this.temp.getRecCnt() != 0 ) {
			Tuple skl = bnls.get_next();
			if ( skl != null ) {
				return skl;
			}
		}
		counter = _window.length;
		return null;
	}



	@Override
	public void close() throws IOException, JoinsException, SortException, IndexException {
		// TODO Auto-generated method stub
		try {
			if ( this.temp.getRecCnt() != 0 ) {
				this.bnls.close();
			}
			temp.deleteFile();

		} catch (InvalidSlotNumberException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (FileAlreadyDeletedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (InvalidTupleSizeException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (HFBufMgrException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (HFDiskMgrException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}



	@Override
	public List<Tuple> get_next_aggr() throws Exception {
		// TODO Auto-generated method stub
		return null;
	}



	@Override
	public KeyDataEntry get_next_key_data() throws ScanIteratorException {
		// TODO Auto-generated method stub
		return null;
	}

}